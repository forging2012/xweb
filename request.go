package xweb

import (
	"bytes"
	"io/ioutil"
	"mime/multipart"
	"net/http"
	"net/url"
	"reflect"
	"strconv"
	"strings"

	"github.com/lunny/tango"
)

type Request struct {
	*http.Request
	logger tango.Logger

	requestBody []byte
}

func NewRequest(request *http.Request, logger tango.Logger) *Request {
	return &Request{request, logger, nil}
}

// Protocol returns request protocol name, such as HTTP/1.1 .
func (req *Request) Protocol() string {
	return req.Request.Proto
}

// Uri returns full request url with query string, fragment.
func (req *Request) Uri() string {
	return req.Request.RequestURI
}

// Url returns request url path (without query string, fragment).
func (req *Request) Url() string {
	return req.Request.URL.String()
}

// Site returns base site url as scheme://domain type.
func (req *Request) Site() string {
	return req.Scheme() + "://" + req.Domain()
}

// Scheme returns request scheme as "http" or "https".
func (req *Request) Scheme() string {
	if req.Request.URL.Scheme != "" {
		return req.Request.URL.Scheme
	} else if req.Request.TLS == nil {
		return "http"
	} else {
		return "https"
	}
}

// Domain returns host name.
// Alias of Host method.
func (req *Request) Domain() string {
	return req.Host()
}

// Host returns host name.
// if no host info in request, return localhost.
func (req *Request) Host() string {
	if req.Request.Host != "" {
		hostParts := strings.Split(req.Request.Host, ":")
		if len(hostParts) > 0 {
			return hostParts[0]
		}
		return req.Request.Host
	}
	return "localhost"
}

// Is returns boolean of this request is on given method, such as Is("POST").
func (req *Request) Is(method string) bool {
	return req.Request.Method == method
}

// IsAjax returns boolean of this request is generated by ajax.
func (req *Request) IsAjax() bool {
	return req.Header("X-Requested-With") == "XMLHttpRequest"
}

// IsSecure returns boolean of this request is in https.
func (req *Request) IsSecure() bool {
	return req.Scheme() == "https"
}

// IsSecure returns boolean of this request is in webSocket.
func (req *Request) IsWebsocket() bool {
	return req.Header("Upgrade") == "websocket"
}

// IsSecure returns boolean of whether file uploads in this request or not..
func (req *Request) IsUpload() bool {
	return req.Request.MultipartForm != nil
}

// IP returns request client ip.
// if in proxy, return first proxy id.
// if error, return 127.0.0.1.
func (req *Request) IP() string {
	ips := req.Proxy()
	if len(ips) > 0 && ips[0] != "" {
		return ips[0]
	}
	ip := strings.Split(req.Request.RemoteAddr, ":")
	if len(ip) > 0 {
		if ip[0] != "[" {
			return ip[0]
		}
	}
	return "127.0.0.1"
}

// Proxy returns proxy client ips slice.
func (req *Request) Proxy() []string {
	if ips := req.Header("X-Forwarded-For"); ips != "" {
		return strings.Split(ips, ",")
	}
	return []string{}
}

// Refer returns http referer header.
func (req *Request) Refer() string {
	return req.Referer()
}

func (req *Request) Referer() string {
	return req.Header("Referer")
}

// SubDomains returns sub domain string.
// if aa.bb.domain.com, returns aa.bb .
func (req *Request) SubDomains() string {
	parts := strings.Split(req.Host(), ".")
	return strings.Join(parts[len(parts)-2:], ".")
}

func (req *Request) GetCookie(cookieName string) (*http.Cookie, error) {
	return req.Request.Cookie(cookieName)
}

// Port returns request client port.
// when error or empty, return 80.
func (req *Request) Port() int {
	parts := strings.Split(req.Request.Host, ":")
	if len(parts) == 2 {
		port, _ := strconv.Atoi(parts[1])
		return port
	}
	return 80
}

// UserAgent returns request client user agent string.
func (req *Request) UserAgent() string {
	return req.Header("User-Agent")
}

// Query returns input data item string by a given string.
func (req *Request) Query(key string) string {
	req.Request.ParseForm()
	return req.Request.Form.Get(key)
}

// Header returns request header item string by a given string.
func (req *Request) Header(key string) string {
	return req.Request.Header.Get(key)
}

// Cookie returns request cookie item string by a given key.
// if non-existed, return empty string.
func (req *Request) Cookie(key string) string {
	ck, err := req.Request.Cookie(key)
	if err != nil {
		return ""
	}
	return ck.Value
}

// ParseStruct mapping forms' name and values to struct's field
// For example:
//		<form>
//			<input name="user.id"/>
//			<input name="user.name"/>
//			<input name="user.age"/>
//		</form>
//
//		type User struct {
//			Id int64
//			Name string
//			Age string
//		}
//
//		var user User
//		err := action.MapForm(&user)
//
func (req *Request) MapForm(st interface{}, names ...string) error {
	v := reflect.ValueOf(st)
	var name string
	if len(names) == 0 {
		name = UnTitle(v.Type().Elem().Name())
	} else {
		name = names[0]
	}
	return namedStructMap(req.logger, v.Elem(), req.Request, name)
}

func (req *Request) Method() string {
	return req.Request.Method
}

func (req *Request) GetSlice(key string) []string {
	return req.Request.Form[key]
}

func (req *Request) GetForm() url.Values {
	return req.Request.Form
}

func (req *Request) GetString(key string) string {
	s := req.GetSlice(key)
	if len(s) > 0 {
		return s[0]
	}
	return ""
}

func (req *Request) GetInt(key string) (int64, error) {
	return strconv.ParseInt(req.GetString(key), 10, 64)
}

func (req *Request) GetBool(key string) (bool, error) {
	return strconv.ParseBool(req.GetString(key))
}

func (req *Request) GetFloat(key string) (float64, error) {
	return strconv.ParseFloat(req.GetString(key), 64)
}

func (req *Request) GetFile(key string) (multipart.File, *multipart.FileHeader, error) {
	return req.Request.FormFile(key)
}

// Body returns the raw request body data as bytes.
func (req *Request) Body() []byte {
	if len(req.requestBody) > 0 {
		return req.requestBody
	}

	requestbody, _ := ioutil.ReadAll(req.Request.Body)
	req.Request.Body.Close()
	bf := bytes.NewBuffer(requestbody)
	req.Request.Body = ioutil.NopCloser(bf)
	req.requestBody = requestbody
	return requestbody
}

type HttpRequestInterface interface {
	SetRequest(*http.Request)
}

type RequestInterface interface {
	SetRequest(*Request)
}

type Requests struct {
	logger tango.Logger
}

func (ii *Requests) SetLogger(logger tango.Logger) {
	ii.logger = logger
}

func (ii *Requests) Handle(ctx *tango.Context) {
	if action := ctx.Action(); action != nil {
		if s, ok := action.(HttpRequestInterface); ok {
			s.SetRequest(ctx.Req())
		}

		if s, ok := action.(RequestInterface); ok {
			s.SetRequest(NewRequest(ctx.Req(), ii.logger))
		}
	}

	ctx.Next()
}
